<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Shi.bro的博客 | 我的个人博客</title>
    <meta property="og:title" content="Shi.bro的博客 | 我的个人博客">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="java,博客,分享">
    <meta name="description" content="专注于IT互联网，JAVA、设计模式、程序员的生存方式">
    <meta property="og:url" content="/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="/index.xml" title="Shi.bro的博客" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="">
                            Shi.bro的博客
                        </a>
                    </h1>
                
                <p class="description">我的个人博客</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="">首页</a>
                    
                    <a  href="/archives/" title="目录">目录</a>
                    
                    <a  href="/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/archives/archives/" title="archives" >archives</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月11日
                            </date>
                            
                            <div class="post-content">
                                这个是archives……
                            </div>
                            <p class="readmore"><a href="/archives/archives/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/about/about/" title="关于" >关于</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月11日
                            </date>
                            
                            <div class="post-content">
                                Hi,欢迎访问我的博客,博主的工作是Java 金融服务开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Java开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.
感谢Hugo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢Hugo提供了这个充***主题.……
                            </div>
                            <p class="readmore"><a href="/about/about/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/readme/" title="readme" >readme</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年9月11日
                            </date>
                            
                            <div class="post-content">
                                  Java  Java8实战阅读笔记  GIT  Java8  Java8实战阅读笔记  GIT  git初始化操作  ……
                            </div>
                            <p class="readmore"><a href="/readme/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/oauth2.0/" title="Oauth2.0" >Oauth2.0</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月25日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/web">Web</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                 异常和错误的区别：异常能被程序本身处理，错误是无法处理。
异常层次结构图 ……
                            </div>
                            <p class="readmore"><a href="/java/oauth2.0/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/web/oauth2.0/" title="Oauth2.0" >Oauth2.0</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月25日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/web">Web</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Oauth2.0 什么是Oauth2.0? OAuth 2.0 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。 简单说：OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。
令牌与密码 令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。 - （1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。
 （2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。
 （3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。
  上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。
OAuth 2.0 对于如何颁发令牌？四种授权类型（authorization grant） 授权码（authorization code）方式 授权码方式指的是：第三方应用先申请一个授权码，然后再用该码获取令牌。 这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。
 第一步:A网站生成授权链接，用户点击后跳转到B网站，授权用户数据给A网站使用。
https://b.com/oauth/authorize? response_type=code&amp; client_id=CLIENT_ID&amp; redirect_uri=CALLBACK_URL&amp; scope=read  主要参数：
 response_type参数表示要求返回授权码（code） client_id参数让 B 知道是谁在请求 redirect_uri参数是 B 接受或拒绝请求后的跳转网址 scope参数表示要求的授权范围（这里是只读）  第二步：跳转到B网站后，需要用户确认授权，用户确认后跳转到第一步的redirect_url，并返回一个授权码。
https://a.com/callback?code=AUTHORIZATION_CODE  第三步：A网站拿到授权码后，后台请求B网站，获取令牌。
https://b.com/oauth/token? client_id=CLIENT_ID&amp; client_secret=CLIENT_SECRET&amp; grant_type=authorization_code&amp; code=AUTHORIZATION_CODE&amp; redirect_uri=CALLBACK_URL  主要参数
 client_id参数和client_secret参数用来让 B 确认 A 的身份（client_secret参数是保密的，因此只能在后端发请求）。 grant_type参数的值是AUTHORIZATION_CODE，表示采用的授权方式是授权码。 code参数是上一步拿到的授权码。 redirect_uri参数是令牌颁发后的回调网址。  第四步：B 网站收到请求以后，就会颁发令牌。具体为向第三 步的redirect_url发送一段令牌json。……
                            </div>
                            <p class="readmore"><a href="/web/oauth2.0/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/condition/" title="Condition" >Condition</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月24日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Condition Condition概述  在线程的同步时可以使一个线程阻塞而等待一个信号，同时放弃锁使其他线程可以能竞争到锁。
 在synchronized中我们可以使用Object的wait()和notify方法实现这种等待和唤醒。
 在Lock可以实现相同的功能就是通过Condition。Condition中的await()和signal()/signalAll()就相当于Object的wait()和notify()/notifyAll()。
 除此之外，Condition还是对多线程条件进行更精确的控制。notify()是唤醒一个线程，但它无法确认是唤醒哪一个线程。 但是，通过Condition，就能明确的指定唤醒读线程。
  参考：https://www.cnblogs.com/qdhxhz/p/9206076.html……
                            </div>
                            <p class="readmore"><a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/condition/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6/" title="线程的生命周期和通讯机制" >线程的生命周期和通讯机制</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月19日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                线程的生命周期和通讯机制 生命周期 ###1、yield()方法 - yield()让当前正在运行的线程回到就绪，以允许具有相同优先级的其他线程获得运行的机会。但是，实际中无法保证yield()达到让步的目的，因为，让步的线程可能被线程调度程序再次选中。
 同时yield()不会放弃锁资源，所以有可能会出现死锁。  ###2、wait和sleep方法的区别 - 1）第一个很重要的区别就是，wait方法必须正在同步环境下使用，比如synchronized方法或者同步代码块。如果你不在同步条件下使用，会抛出IllegalMonitorStateException异常。另外，sleep方法不需要再同步条件下调用，你可以任意正常的使用。
 2）第二个区别是，wait方法用于和定义于Object类的，而sleep方法操作于当前线程，定义在java.lang.Thread类里面。
 3）第三个区别是，调用wait()的时候方法会释放当前持有的锁，而sleep方法不会释放任何锁。
  ###3、wait和sleep方法使用场景 -（1）wait方法定义在Object类里面，所有对象都能用到，一般wait()和notify()方法或notifyAll使用于线程间的通信。
-（2）sleep()方法用于暂停当前线程的执行。
###4、join方法（） - thread.Join把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。 - 比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 ###5、stop方法 线程启动完毕后,在运行可能需要终止,Java提供的终止方法只有一个stop,但是不建议使用此方法,因为它有以下三个问题:
 1)stop方法是过时的。   从Java编码规则来说,已经过时的方式不建议采用.
  2)stop方法会导致代码逻辑不完整   stop方法是一种&rdquo;恶意&rdquo; 的中断,一旦执行stop方法,即终止当前正在运行的线程,不管线程逻辑是否完整,这是非常危险的.
  3)stop方法会破坏原子逻辑   多线程为了解决共享资源抢占的问题,使用了锁的概念,避免资源不同步,但是正是因为此原因,stop方法却会带来更大的麻烦,它会丢弃所有的锁,导致原子逻辑受损
 线程通讯 1.依次运行用join 2.交叉运行用wait()和notify()或者notifyAll() 3.四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的。 用CountdownLatch,主要方法latch.await(),latch.countDown();
4.三个运动员各自准备，等到三个人都准备好后，再一起跑 用CyclicBarrier
5.子线程完成某件任务后，把得到的结果回传给主线程 用FutureTask和Callable……
                            </div>
                            <p class="readmore"><a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%80%9A%E8%AE%AF%E6%9C%BA%E5%88%B6/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/2.gc%E7%AE%97%E6%B3%95%E5%92%8C%E7%A7%8D%E7%B1%BB/" title="GC算法和种类" >GC算法和种类</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月18日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                GC算法和种类 GC的工作区域 1.不是GC的工作区域 程序计数器、虚拟机栈和本地方法栈三个区域是线程私有的，随线程生而生，随线程灭而灭； 在这几个区域不需要过多考虑回收的问题方法结束或线程结束时，内存自然就跟随着回收了。 2.GC的工作区域（哪些内存需要GC回收？） 垃圾回收重点关注的是堆和方法区部分的内存。 程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，所以垃圾回收器所关注的主要是这部分的内存。 垃圾对象的判定 Java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，哪些还活着。对象死去的时候才需要回收。 1. 引用计数法 在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。 如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。 2. 可达性分析算法 通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的。
可作为GC Roots的对象包括下面几种： (1)虚拟机栈（栈帧中的本地变量表）中引用的对象。 (2)方法区中的常量、类静态属性引用的对象。 (3)本地方法栈中JNI（Native方法）的引用对象。
垃圾回收算法  标记清除算法 (1). 标记阶段：找到所有可访问的对象，做个标记 (2). 清除阶段：遍历堆，把未被标记的对象回收 缺点： （1）因为涉及大量的内存遍历工作，所以执行性能较低 （2）对象被清除之后，被清除的对象留下内存的空缺位置会造成内存不连续，空间浪费。
 标记整理算法 适合用于存活对象较多的场合，如老年代。 (1)、标记阶段：它的第一个阶段与标记/清除算法是一模一样的。 (2)、整理阶段：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。 优点：内存连续，消除复制算法内存减半的代价问题 缺点:不仅要标记所有存活对象，还要整理所有存活对象的引用地址。性能低于复制算法。
 复制算法 复制算法简单来说就是把内存一分为二，但只使用其中一份，在垃圾回收时，将正在使用的那份内存中存活的对象复制到另一份空白的内存中，最后将正在使用的内存空间的对象清除，完成垃圾回收。 优点：复制算法使得每次都只对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。 缺点：复制算法的代价是将内存缩小为原来的一半，这个太要命了。
  **现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一块为Eden（伊甸区）和两块较小的Survivor（幸存区）空间(默认比例-&gt;8:1:1)。每次使用Eden和其中的一块Survivor，垃圾回收时候将上述两块中存活的对象复制到另外一块Survivor上，同时清理上述Eden和Survivor。所以每次新生代就可以使用90%的内存。只有10%的内存是浪费的。(不能保证每次新生代都少于10%的对象存活，当在垃圾回收复制时候如果一块Survivor不够时候，需要老年代来分担，大对象直接进入老年代) **
总的来讲：复制算法不适用于存活对象较多的场合，如老年代（复制算法适合做新生代的GC）
三种算法比较 相同点： 进行GC时需要暂停应用程序。 区别： 效率：复制算法&gt;标记-整理算法&gt;标记-清除算法； 内存整齐度：复制算法=标记-整理算法&gt;标记-清除算法 内存利用率：标记-整理算法=标记-清除算法&gt;复制算法
分代收集思想 新生代：由于存活的对象相对比较少，因此可以采用复制算法该算法效率比较快。 &gt; 新生代包含Eden（伊甸区）和两块Survivor(幸存区)
老年代：由于存活的对象比较多哈，可以采用标记-清除算法或是标记-整理算法。
 java8以后，已经没有(PermGen Space)永久区了，之前永久区存放的东西基本上放到了元空间（Meta Space）中。
 参考：https://www.cnblogs.com/qdhxhz/p/9211095.html1……
                            </div>
                            <p class="readmore"><a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/2.gc%E7%AE%97%E6%B3%95%E5%92%8C%E7%A7%8D%E7%B1%BB/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="垃圾回收器" >垃圾回收器</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月18日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                垃圾回收器 GC的工作区域 基础概念 1、并发和并行 - a：并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 - b：并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。
2、新生代 GC 和老年代GC - a:新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。 - b:老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的）。Major GC的速度一般会比Minor GC慢10倍以上。
3、吞吐量 - 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。
 虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。
 垃圾收集器  Serial收集器  新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩;收集过程中服务会暂停。 参数控制：-XX:+UseSerialGC 串行收集器  ParNew收集器
 新生代并行，老年代串行；新生代复制算法、老年代标记-压缩；ParNew收集器其实就是Serial收集器的多线程版本。 参数控制：  -XX:+UseParNewGC ParNew收集器 -XX:ParallelGCThreads 限制线程数量   Parallel Scavenge收集器
 新生代复制算法。老年代标记压缩，串行 参数控制：-XX:+UseParallelGC   Serial Old收集器
 它是Serial收集器的老年代版，它同样是一个单线程收集器，使用“标记&ndash;整理”算法。
  Parallel Old 收集器……
                            </div>
                            <p class="readmore"><a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/3.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/4.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" title="性能调优" >性能调优</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年12月18日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                性能调优 调优策略 调优的目的 调优的最终目的当然增大吞吐量，减少暂停时间，映射到GC层面主要关心下面这两点： (1)将转移到老年代的对象数量降低到最小。 (2)减少full GC的执行时间。（尽量减少GC的次数）
那什么情况对象会转移到老年代 主要有这四种：
(1)新生代对象每经历依次minor gc，年龄会加一，当达到年龄阀值会直接进入老年代。阀值大小一般为15。 (2)Survivor空间中年龄所有对象大小的总和大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，而无需等到年龄阀值。 (3)大对象直接进入老年代。 (4)新生代复制算法需要一个survivor区进行轮换备份，如果出现大量对象在minor gc后仍然存活的情况时，就需要老年代进行分配担保，让survivor无法容纳的对象直接进入老年代。
再来分析为什么说要减少full GC时间次数，那得先看GC的两大分类
 Partial GC：并不收集整个GC堆的模式  Young GC：只收集young gen的GC Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式 Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式  Full GC：针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。
 一般Full GC所花费的时间是Young GC的十倍,这里就明白为什么要减少Full GC的次数了。
  哪些方面可以考虑调优？ （1）减少使用全局变量和大对象。 （2）新生代和老年代的大小是否合适。 （3）新生代和老年代所占的比例是否合适。 （4）幸存者区和新生区所占的比例到是否合适。 （5）选择合适的GC收集器。
什么情况说明GC已经不错了呢？ 此外，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了： Minor GC执行非常迅速（50ms以内） Minor GC没有频繁执行（大约10s执行一次） Full GC执行非常迅速（1s以内） Full GC没有频繁执行（大约10min执行一次） 括号中的数字并不是绝对的，它们也随着服务的状态而变化。
二、调优经验(规则) 这些规则，一般是大家比较建议的，可以作为初始配置的时候进行配置建议，当然具体的还得通过JVM工具监测来具体分析。 (1) -Xmx 和-Xms 一般设置为一样大小。这样能稍微提高GC的运行效率，因为他/她不再需要估算堆是否需要调整大小了。
(2)官方推荐新生代占堆的3/8。 (3)幸存代占新生代的1/10。 (4)垃圾收集器如果内存比较大建议G1收集器，当然也可以用CMS收集器。 (5)-XX:+DisableExplicitGC禁止System.……
                            </div>
                            <p class="readmore"><a href="/java/jvm%E8%99%9A%E6%8B%9F%E6%9C%BA/4.%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">阅读全文</a></p>
                        </article>
                    
                    



<ol class="page-navigator">
    

    
    <li  class="current">
        <a href="/">1</a>
    </li>
    
    <li >
        <a href="/page/2/">2</a>
    </li>
    
    <li >
        <a href="/page/3/">3</a>
    </li>
    
    <li >
        <a href="/page/4/">4</a>
    </li>
    
    <li >
        <a href="/page/5/">5</a>
    </li>
    
    <li >
        <a href="/page/6/">6</a>
    </li>
    
    <li >
        <a href="/page/7/">7</a>
    </li>
    
    <li >
        <a href="/page/8/">8</a>
    </li>
    

    
    <li class="next">
        <a href="/page/2/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="/categories/algorithm/">algorithm(1)</a>
    </li>
    
    <li>
        <a href="/categories/git/">git(1)</a>
    </li>
    
    <li>
        <a href="/categories/java/">java(31)</a>
    </li>
    
    <li>
        <a href="/categories/linux/">linux(1)</a>
    </li>
    
    <li>
        <a href="/categories/markdown/">markdown(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql/">mysql(2)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E7%B4%A2%E5%BC%95/">mysql索引(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E9%94%81/">mysql锁(2)</a>
    </li>
    
    <li>
        <a href="/categories/other/">other(4)</a>
    </li>
    
    <li>
        <a href="/categories/spring/">spring(12)</a>
    </li>
    
    <li>
        <a href="/categories/sql/">sql(2)</a>
    </li>
    
    <li>
        <a href="/categories/todo/">todo(1)</a>
    </li>
    
    <li>
        <a href="/categories/web/">web(6)</a>
    </li>
    
    <li>
        <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发(1)</a>
    </li>
    
    <li>
        <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(4)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="/tags/algorithm/">algorithm</a>
    
    <a href="/tags/git/">git</a>
    
    <a href="/tags/guava/">guava</a>
    
    <a href="/tags/h5/">h5</a>
    
    <a href="/tags/java/">java</a>
    
    <a href="/tags/java8/">java8</a>
    
    <a href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/">java并发编程艺术</a>
    
    <a href="/tags/jvm/">jvm</a>
    
    <a href="/tags/linux/">linux</a>
    
    <a href="/tags/markdown/">markdown</a>
    
    <a href="/tags/mysql/">mysql</a>
    
    <a href="/tags/other/">other</a>
    
    <a href="/tags/spring/">spring</a>
    
    <a href="/tags/spring%E4%BA%8B%E5%8A%A1/">spring事务</a>
    
    <a href="/tags/sql/">sql</a>
    
    <a href="/tags/todo/">todo</a>
    
    <a href="/tags/web/">web</a>
    
    <a href="/tags/wechat/">wechat</a>
    
    <a href="/tags/xml/">xml</a>
    
    <a href="/tags/%E5%85%B6%E4%BB%96/">其他</a>
    
    <a href="/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">创建型模式</a>
    
    <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    
    <a href="/tags/%E5%AE%89%E5%85%A8/">安全</a>
    
    <a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="/tags/%E5%BC%82%E5%B8%B8/">异常</a>
    
    <a href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">结构型模式</a>
    
    <a href="/tags/%E7%BC%93%E5%AD%98/">缓存</a>
    
    <a href="/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">行为型模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/">设计模式分类</a>
    
    <a href="/tags/%E9%94%81/">锁</a>
    
    <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
    
</div>
    </section>

    

    
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2020 <a href="">Shi.bro的博客 By Shi.bro</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
