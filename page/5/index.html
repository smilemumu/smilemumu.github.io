<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Shi.bro的博客 | 我的个人博客</title>
    <meta property="og:title" content="Shi.bro的博客 | 我的个人博客">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="java,博客,分享">
    <meta name="description" content="专注于IT互联网，JAVA、设计模式、程序员的生存方式">
    <meta property="og:url" content="/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="/index.xml" title="Shi.bro的博客" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="">
                            Shi.bro的博客
                        </a>
                    </h1>
                
                <p class="description">我的个人博客</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="">首页</a>
                    
                    <a  href="/archives/" title="目录">目录</a>
                    
                    <a  href="/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E5%85%B6%E4%BB%96/" title="其他" >其他</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月20日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                其他一些日常工作中遇到的问题：
1.如果需要在sit环境引入多个配置文件,比如application.yml何application-common.yml,只需要在application.yml中加入spring.profiles.include = common即可。 2.@Scope默认是单例模式，即scope=&ldquo;singleton&rdquo;。 另外scope还有prototype、request、session、global session作用域。scope=&ldquo;prototype&rdquo;多例 3.@Aspect执行顺序问题 Aspect先执行是随机的，如果需要定义顺序，可以使用@Order注解修饰Aspect类。值越小，优先级越高。……
                            </div>
                            <p class="readmore"><a href="/spring/%E5%85%B6%E4%BB%96/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/" title="基于自定义注解的参数解析器" >基于自定义注解的参数解析器</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                基于自定义注解的参数解析器 背景 在工作中，常会对接一些第三方应用，通常第三方会采用Rsa+Aes加密来通信，但是每个第三方的加密方式可能不一致。此时得好好规划一下实现方案了。因此我们采用注解+Spring自带了参数解析类，实现自己的参数解析器。
原理 通过HandlerMethodArgumentResolver实现自定义参数解析
实现 步骤1：创建注解，例如创建一个解析Aes加密的注解AesJson import java.lang.annotation.*; @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AesJson { }  步骤2：创建加密参数实体类对象 传入的JSON数据格式为{&ldquo;data&rdquo;:&ldquo;xxxxxxxxxx&rdquo;}
import lombok.Data; @Data public class AesBaseParams { private String data; }  步骤3：新建AesArgumentResolver类实现HandlerMethodArgumentResolver import com.alibaba.fastjson.JSON; import org.apache.commons.lang.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.MethodParameter; import org.springframework.web.bind.support.WebDataBinderFactory; import org.springframework.web.context.request.NativeWebRequest; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.method.support.ModelAndViewContainer; import javax.servlet.http.HttpServletRequest; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.URLDecoder; import java.util.HashMap; import java.util.Map; import java.util.Objects; /** * aes加密算法加密的入参，通过@AesJson注解自动解析 */ public class AesArgumentResolver implements HandlerMethodArgumentResolver { private static final Logger logger = LoggerFactory.……
                            </div>
                            <p class="readmore"><a href="/spring/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81/" title="接口限流-令牌桶限流" >接口限流-令牌桶限流</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                guava之令牌桶算法实现接口限流 实现步骤 1.创建注解RateLimit import java.lang.annotation.*; /** * 自定义注解：限流令牌桶注解，用以创建令牌桶以及设定令牌桶大小 */ @Inherited @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { double limitNum() default 20; //默认每秒放入桶中20 }  2.创建令牌桶切面RateLimitAspect import com.google.common.util.concurrent.RateLimiter; import com.shizhongcai.business.common.annotation.RateLimit; import com.shizhongcai.business.common.domain.enums.ErrorCodesEnum; import com.shizhongcai.business.common.exception.BaseException; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; import java.lang.reflect.Method; import java.util.concurrent.ConcurrentHashMap; /** * 令牌桶切面，桶中无令牌进行服务降级 * */ @Component @Scope @Aspect public class RateLimitAspect { //用来存放不同接口的RateLimiter令牌桶(key为接口名称，value为RateLimiter) //ConcurrentHashMap线程安全 private ConcurrentHashMap&lt;String, RateLimiter&gt; map = new ConcurrentHashMap&lt;&gt;(); //令牌桶 private RateLimiter rateLimiter; @Pointcut(&quot;@annotation(com.……
                            </div>
                            <p class="readmore"><a href="/spring/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96mdc/" title="日志优化MDC" >日志优化MDC</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                MDC(Mapped Diagnostic Context) 实现 步骤1：创建MDCFilter实现Filter filter（过滤器）作用于在intreceptor(拦截器)之前，不像intreceptor一样依赖于springmvc框架，只需要依赖于serverlet。 在过滤之前在reqId钟放入uuid并在结束之后remove
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.slf4j.MDC; import org.springframework.stereotype.Component; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.util.UUID; /** * @Author shizhongcai * @Date 2019/11/15 11:15 */ @Component public class MDCFilter implements Filter { private static final Logger LOG = LoggerFactory.getLogger(MDCFilter.class); public static final String MDC_ID = &quot;reqId&quot;; @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { boolean mdcFlag = false; try { MDC.……
                            </div>
                            <p class="readmore"><a href="/spring/%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96mdc/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/" title="统一返回对象" >统一返回对象</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                1.创建实体类BaseRspVo
@Data public class BaseRspVo&lt;T&gt; { private boolean success; private String msg; private Integer errorCode; private T data; public BaseRspVo() { } public BaseRspVo (T data){ this.success = true; this.msg= ErrorCodesEnum.SUCCESS.getMsg(); this.errorCode = ErrorCodesEnum.SUCCESS.getCode(); this.data = data; } public BaseRspVo(ErrorCodesEnum errorCode) { if(errorCode == ErrorCodesEnum.SUCCESS) { this.success = true; } else { this.success = false; } this.msg = errorCode.getMsg(); this.errorCode = errorCode.getCode(); } } 错误Code枚举类 public enum ErrorCodesEnum { SUCCESS(10000,&quot;成功&quot;), SYS_ERROR(1000,&quot;系统异常，请稍后再试&quot;), DUPLICATE_KEY(10001,&quot;数据库中已存在该记录&quot;), NO_HANDLER_FOUND(10002,&quot;路径不存在，请检查路径是否正确&quot;), DEFAULT_FAIL(10003,&quot;未知异常，请稍后再试&quot;), DECRYPT_ERROR(10004,&quot;解密出错&quot;), ; /** * 错误码 */ private int code; /** * 错误描述 */ private String msg; ErrorCodesEnum(int code, String msg) { this.……
                            </div>
                            <p class="readmore"><a href="/spring/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/todo/" title="项目开发" >项目开发</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Spring中Filter和Interceptor的区别 全局异常处理 统一返回结果对象 日志优化MDC(Mapped Diagnostic Context)的类（技术上使用了ThreadLocal实现，重点技术） 基于自定义注解的参数解析器（通过HandlerMethodArgumentResolver实现） 基于自定义注解的结果包装统一返回（通过HandlerMethodReturnValueHandler实现） 接口限流-令牌桶限流 参数校验-JSR-303  ……
                            </div>
                            <p class="readmore"><a href="/spring/todo/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/spring/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="项目开发" >项目开发</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月14日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/spring">Spring</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Spring中Filter和Interceptor的区别 全局异常处理 统一返回结果对象 日志优化MDC(Mapped Diagnostic Context)的类（技术上使用了ThreadLocal实现，重点技术） 基于自定义注解的参数解析器（通过HandlerMethodArgumentResolver实现） 基于自定义注解的结果包装统一返回（通过HandlerMethodReturnValueHandler实现） 接口限流-令牌桶限流 参数校验-JSR-303  ……
                            </div>
                            <p class="readmore"><a href="/spring/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/io%E6%B5%81/" title="JAVA IO流" >JAVA IO流</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月7日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Java IO流 Java 中 IO 流分为几种?  按照流的流向分，可以分为输入流和输出流；  输出流：从内存读出到文件。只能进行写操作。 输入流：从文件读入到内存。只能进行读操作。 输入和输出，都是相对于系统内存而言  按照操作单元划分，可以划分为字节流和字符流；  字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。(1byte（B） = 8bit(位)) 字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。(1字符=2字节 )  按照流的角色划分为节点流和处理流。  节点流：直接与数据源相连，读入或读出。 处理流（Filter Stream）：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。（DataInputStream、BufferedInputStream、BufferedReader等）   Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。 - InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 - OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
不同平台的换行符号： |符号|linux|windows|Java建议写法| |-|-|-|-| |换行符|\n|\r\n|System.getProperty(&ldquo;line.separator&rdquo;)| |路径分隔符|/|\|File.separator| |多个路径分隔符|:|;|File.pathSeparator|
字节流和字符流的区别: 字符流使用了缓存区（内存），执行了write()，文件中不会立刻有内容（除非缓冲区满了或者主动刷新缓冲区），需要等输出流对象关闭了，文件中才会有内容；字节流不使用缓冲区，执行了wirite()，文件中立刻就有内容了。 - ### 1.字符流
//步骤为:程序-&gt;字符流-&gt;缓存(数据先存放到缓存，再从缓存写入文件【主动刷新or流关闭】)-&gt;文件 import java.util.*; import java.io.*; public class WriterTest { public static void main(String[] args) { File file = new File(&quot;1.txt&quot;); Scanner in = null; Writer out = null; try{ in = new Scanner(System.……
                            </div>
                            <p class="readmore"><a href="/java/io%E6%B5%81/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/java%E5%9F%BA%E7%A1%80/" title="JAVA基础" >JAVA基础</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月5日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Java基础知识 1. String 、StringBuilder 、StringBuffer String 类中使用 final 关键字修饰字符数组来保存字符串，private　final　char　value[]，所以 String 对象是不可变的。 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结：
操作少量的数据: 适用String 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer  2.== 和 equals == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。  说明： - String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 - 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。……
                            </div>
                            <p class="readmore"><a href="/java/java%E5%9F%BA%E7%A1%80/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/automic/" title="Automic" >Automic</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年10月18日
                            </date>
                            
                            <div class="post-meta">
                                <span>|</span>
                                
                                <span class="meta-category"><a href="/categories/java">java</a></span>
                                
                            </div>
                            
                            <div class="post-content">
                                Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 所以，所谓原子类说简单点就是具有原子/原子操作特征的类
public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。  基本数据类型原子类优势 - ①多线程环境不使用原子类保证线程安全（基本数据类型）
class Test { private volatile int count = 0; //若要线程安全执行执行count++，需要加锁 public synchronized void increment() { count++; } public int getCount() { return count; } }   ②多线程环境使用原子类保证线程安全……
                            </div>
                            <p class="readmore"><a href="/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/automic/">阅读全文</a></p>
                        </article>
                    
                    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="/page/4/">上一页</a>
    </li>
    

    
    <li >
        <a href="/">1</a>
    </li>
    
    <li >
        <a href="/page/2/">2</a>
    </li>
    
    <li >
        <a href="/page/3/">3</a>
    </li>
    
    <li >
        <a href="/page/4/">4</a>
    </li>
    
    <li  class="current">
        <a href="/page/5/">5</a>
    </li>
    
    <li >
        <a href="/page/6/">6</a>
    </li>
    
    <li >
        <a href="/page/7/">7</a>
    </li>
    
    <li >
        <a href="/page/8/">8</a>
    </li>
    

    
    <li class="next">
        <a href="/page/6/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="/categories/algorithm/">algorithm(1)</a>
    </li>
    
    <li>
        <a href="/categories/git/">git(1)</a>
    </li>
    
    <li>
        <a href="/categories/java/">java(31)</a>
    </li>
    
    <li>
        <a href="/categories/linux/">linux(1)</a>
    </li>
    
    <li>
        <a href="/categories/markdown/">markdown(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql/">mysql(2)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E7%B4%A2%E5%BC%95/">mysql索引(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E9%94%81/">mysql锁(2)</a>
    </li>
    
    <li>
        <a href="/categories/other/">other(4)</a>
    </li>
    
    <li>
        <a href="/categories/spring/">spring(12)</a>
    </li>
    
    <li>
        <a href="/categories/sql/">sql(2)</a>
    </li>
    
    <li>
        <a href="/categories/todo/">todo(1)</a>
    </li>
    
    <li>
        <a href="/categories/web/">web(6)</a>
    </li>
    
    <li>
        <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发(1)</a>
    </li>
    
    <li>
        <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(4)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="/tags/algorithm/">algorithm</a>
    
    <a href="/tags/git/">git</a>
    
    <a href="/tags/guava/">guava</a>
    
    <a href="/tags/h5/">h5</a>
    
    <a href="/tags/java/">java</a>
    
    <a href="/tags/java8/">java8</a>
    
    <a href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/">java并发编程艺术</a>
    
    <a href="/tags/jvm/">jvm</a>
    
    <a href="/tags/linux/">linux</a>
    
    <a href="/tags/markdown/">markdown</a>
    
    <a href="/tags/mysql/">mysql</a>
    
    <a href="/tags/other/">other</a>
    
    <a href="/tags/spring/">spring</a>
    
    <a href="/tags/spring%E4%BA%8B%E5%8A%A1/">spring事务</a>
    
    <a href="/tags/sql/">sql</a>
    
    <a href="/tags/todo/">todo</a>
    
    <a href="/tags/web/">web</a>
    
    <a href="/tags/wechat/">wechat</a>
    
    <a href="/tags/xml/">xml</a>
    
    <a href="/tags/%E5%85%B6%E4%BB%96/">其他</a>
    
    <a href="/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">创建型模式</a>
    
    <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    
    <a href="/tags/%E5%AE%89%E5%85%A8/">安全</a>
    
    <a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="/tags/%E5%BC%82%E5%B8%B8/">异常</a>
    
    <a href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">结构型模式</a>
    
    <a href="/tags/%E7%BC%93%E5%AD%98/">缓存</a>
    
    <a href="/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">行为型模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/">设计模式分类</a>
    
    <a href="/tags/%E9%94%81/">锁</a>
    
    <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
    
</div>
    </section>

    

    
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2020 <a href="">Shi.bro的博客 By Shi.bro</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
