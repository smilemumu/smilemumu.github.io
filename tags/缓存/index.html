<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>缓存 | Shi.bro的博客</title>
    <meta property="og:title" content="缓存 - Shi.bro的博客">
    <meta property="og:type" content="article">
        
        
    <meta name="Keywords" content="java,博客,分享">
    <meta name="description" content="缓存">
        
    <meta name="author" content="Shi.bro">
    <meta property="og:url" content="/tags/%E7%BC%93%E5%AD%98/">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="/css/normalize.css">
    
    <link rel="stylesheet" href="/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="/tags/%E7%BC%93%E5%AD%98/index.xml" title="Shi.bro的博客" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <a id="logo" href="">
                        Shi.bro的博客
                    </a>
                
                <p class="description">我的个人博客</p>
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="" href="">首页</a>
                    
                    <a  href="/archives/" title="目录">目录</a>
                    
                    <a  href="/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                    <h3 class="archive-title">
                        包含标签
                        <span class="keyword">缓存</span>
                        的文章
                    </h3>
                    

                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/%E5%B8%83%E9%9A%86bloom%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆Bloom过滤器</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年10月16日
                            </date>
                            
                            <div class="post-meta meta-category">
                                |
                                
                                    <a href="/categories/java">java</a>
                                
                            </div>
                            
                            <div class="post-content">
                                1.什么是布隆过滤器？  一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。 &gt;位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000&frasl;1024 kb ≈ 122kb 的空间。 &gt; bit数组 0 0 0 0 0 0 0 0 0 0 0 0 0 0  2.布隆过滤器的原理  当一个元素加入布隆过滤器中的时候，会进行如下操作：
 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。 根据得到的哈希值，在位数组中把对应下标的值置为 1。   当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：
 对给定元素再次进行相同的哈希计算； 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。    布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。
 3.使用Google开源的 Guava中自带的布隆过滤器  创建了一个最多存放 最多 1500个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.……
                                <p class="readmore"><a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/%E5%B8%83%E9%9A%86bloom%E8%BF%87%E6%BB%A4%E5%99%A8/">阅读全文</a></p>
                            </div>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/java%E7%BC%93%E5%AD%98/">Java缓存</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2020年10月12日
                            </date>
                            
                            <div class="post-meta meta-category">
                                |
                                
                                    <a href="/categories/java">java</a>
                                
                            </div>
                            
                            <div class="post-content">
                                 缓存 1.基本思想  避免用户在请求数据的时候获取速度过于缓慢，所以我们在数据库之上增加了缓存这一层来弥补。  2.本地缓存解决方案  常见的有Ehcache、guavaCache、Caffeine Cache等，性能最优的为Caffeine cache。 常见的单体架构使用 Nginx 来做负载均衡，部署两个相同的服务到服务器，两个服务使用同一个数据库，并且使用的是本地缓存。
3.为什么要用分布式缓存？而不用本地缓存？ 本地缓存存在局限性：
 本地缓存对分布式架构支持不友好，比如同一个相同的服务部署在多台机器上的时候，各个服务之间的缓存是无法共享的，因为本地缓存只在当前机器上有。 本地缓存容量受服务部署所在的机器限制明显。 如果当前系统服务所耗费的内存多，那么本地缓存可用的容量就很少。   4.缓存读写模式/更新策略/处理流程  Cache Aside Pattern（旁路缓存模式）  读：从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。 写：更新 DB，然后直接删除 cache 。  Read/Write Through Pattern（读写穿透）  读：从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。 写：先查 cache，cache 中不存在，直接更新 DB。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 DB（同步更新 cache 和 DB）。  Write Behind Pattern（异步缓存写入）  读：从 cache 中读取数据，读取到就直接返回 。读取不到的话，先从 DB 加载，写入到 cache 后返回响应。 写：无论是否存在，都直接跟新缓存，最好异步批量的方式来更新 DB。   ……
                                <p class="readmore"><a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/java%E7%BC%93%E5%AD%98/">阅读全文</a></p>
                            </div>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/caffeine-cache%E6%8E%A5%E5%85%A5/">Caffeine Cache接入</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月20日
                            </date>
                            
                            <div class="post-meta meta-category">
                                |
                                
                                    <a href="/categories/java">java</a>
                                
                            </div>
                            
                            <div class="post-content">
                                 Caffeine Cache接入  Caffeine Cache，目前最快的Java内存框架，堆内存。
 接入方式：
 1.引入pom文件
&lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt;  2.编写CaffeineConfig并注入CacheManager
import org.springframework.cache.CacheManager; import org.springframework.cache.annotation.CachingConfigurerSupport; import org.springframework.cache.annotation.EnableCaching; import org.springframework.cache.caffeine.*; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.github.benmanes.caffeine.cache.Caffeine; import java.util.concurrent.TimeUnit; @Configuration @EnableCaching public class CaffeineConfig extends CachingConfigurerSupport { @Bean public CacheManager caffeineCacheManager() { CaffeineCacheManager cacheManager = new CaffeineCacheManager(); //定制化缓存Cache cacheManager.setCaffeine(Caffeine.newBuilder() .expireAfterWrite(3, TimeUnit.MINUTES) .initialCapacity(100) .maximumSize(10000)) ; return cacheManager; } }  3.通过注解使用
@Cacheable(cacheNames = &quot;cache name&quot;, key = &quot;#patam1+'-'+#param2&quot;) public void test(String param1,String param2){ }     ……
                                <p class="readmore"><a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/caffeine-cache%E6%8E%A5%E5%85%A5/">阅读全文</a></p>
                            </div>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/redis%E7%BC%93%E5%AD%98/">Redis缓存</a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                2019年11月20日
                            </date>
                            
                            <div class="post-meta meta-category">
                                |
                                
                                    <a href="/categories/java">java</a>
                                
                            </div>
                            
                            <div class="post-content">
                                1.Redis简单介绍  语言开发的内存数据库，除了做KV缓存外还能做分布式锁、延时队列、定时任务等等  2.缓存读写模式/更新策略/处理流程  Cache Aside Pattern（旁路缓存模式） Read/Write Through Pattern（读写穿透） Write Behind Pattern（异步缓存写入）  3.为什么要用 Redis/为什么要用缓存？  简单来说使用缓存主要是为了提高接口响应速度，提升用户体验以及应对更多的用户。 高性能：对于高频数据并且不会经常改变的数据，保证下一次用户访问的数据直接从缓存中读取。 高并发：数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+， &gt; QPS（Query Per Second）：服务器每秒可以执行的查询次数；  4.Redis 常见数据结构以及使用场景分析 4.1 String  普通操作：
127.0.0.1:6379&gt; set key value #设置 key-value 类型的值 OK 127.0.0.1:6379&gt; get key # 根据 key 获得对应的 value &quot;value&quot; 127.0.0.1:6379&gt; exists key # 判断某个 key 是否存在 (integer) 1 127.……
                                <p class="readmore"><a href="/java/%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6/redis%E7%BC%93%E5%AD%98/">阅读全文</a></p>
                            </div>
                        </article>
                    

                    





                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="/categories/algorithm/">algorithm(1)</a>
    </li>
    
    <li>
        <a href="/categories/git/">git(1)</a>
    </li>
    
    <li>
        <a href="/categories/java/">java(31)</a>
    </li>
    
    <li>
        <a href="/categories/linux/">linux(1)</a>
    </li>
    
    <li>
        <a href="/categories/markdown/">markdown(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql/">mysql(2)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E7%B4%A2%E5%BC%95/">mysql索引(1)</a>
    </li>
    
    <li>
        <a href="/categories/mysql%E9%94%81/">mysql锁(2)</a>
    </li>
    
    <li>
        <a href="/categories/other/">other(4)</a>
    </li>
    
    <li>
        <a href="/categories/spring/">spring(12)</a>
    </li>
    
    <li>
        <a href="/categories/sql/">sql(2)</a>
    </li>
    
    <li>
        <a href="/categories/todo/">todo(1)</a>
    </li>
    
    <li>
        <a href="/categories/web/">web(6)</a>
    </li>
    
    <li>
        <a href="/categories/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/">微信开发(1)</a>
    </li>
    
    <li>
        <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式(4)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="/tags/algorithm/">algorithm</a>
    
    <a href="/tags/git/">git</a>
    
    <a href="/tags/guava/">guava</a>
    
    <a href="/tags/h5/">h5</a>
    
    <a href="/tags/java/">java</a>
    
    <a href="/tags/java8/">java8</a>
    
    <a href="/tags/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF/">java并发编程艺术</a>
    
    <a href="/tags/jvm/">jvm</a>
    
    <a href="/tags/linux/">linux</a>
    
    <a href="/tags/markdown/">markdown</a>
    
    <a href="/tags/mysql/">mysql</a>
    
    <a href="/tags/other/">other</a>
    
    <a href="/tags/spring/">spring</a>
    
    <a href="/tags/spring%E4%BA%8B%E5%8A%A1/">spring事务</a>
    
    <a href="/tags/sql/">sql</a>
    
    <a href="/tags/todo/">todo</a>
    
    <a href="/tags/web/">web</a>
    
    <a href="/tags/wechat/">wechat</a>
    
    <a href="/tags/xml/">xml</a>
    
    <a href="/tags/%E5%85%B6%E4%BB%96/">其他</a>
    
    <a href="/tags/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">创建型模式</a>
    
    <a href="/tags/%E5%9F%BA%E7%A1%80/">基础</a>
    
    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
    
    <a href="/tags/%E5%AE%89%E5%85%A8/">安全</a>
    
    <a href="/tags/%E5%B9%B6%E5%8F%91/">并发</a>
    
    <a href="/tags/%E5%BC%82%E5%B8%B8/">异常</a>
    
    <a href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">结构型模式</a>
    
    <a href="/tags/%E7%BC%93%E5%AD%98/">缓存</a>
    
    <a href="/tags/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/">行为型模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
    
    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB/">设计模式分类</a>
    
    <a href="/tags/%E9%94%81/">锁</a>
    
    <a href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发</a>
    
</div>
    </section>

    

    
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2020 <a href="">Shi.bro的博客 By Shi.bro</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="/js/totop.js?v=0.0.0" async=""></script>







</body>
</html>
