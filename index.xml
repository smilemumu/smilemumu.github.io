<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Shi.bro的博客</title>
    <link>http://www.sszblog.xyz/</link>
    <description>Recent content on Shi.bro的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 21 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="http://www.sszblog.xyz/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>archives</title>
      <link>http://www.sszblog.xyz/archives/archives/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/archives/archives/</guid>
      <description>这个是archives</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>http://www.sszblog.xyz/about/about/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/about/about/</guid>
      <description>Hi,欢迎访问我的博客,博主的工作是Java 金融服务开发,平时对其他各种技术也有兴趣,本博客会更新一些我平常工作和业余接触到的技术知识,以Java开发为主,博主也是半个技术小白,目前正在自我进化中,如果各位看到文章中有错误或者想要提问,欢迎与我联系,我会尽快改正或尽力解答.
感谢Hugo提供了优秀的博客静态生成部署框架,也感谢GitHub Page提供免费的网页部署空间,也感谢Hugo提供了这个充***主题.</description>
    </item>
    
    <item>
      <title>readme</title>
      <link>http://www.sszblog.xyz/readme/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/readme/</guid>
      <description>  Java  Java8实战阅读笔记  GIT  Java8  Java8实战阅读笔记  GIT  git初始化操作  </description>
    </item>
    
    <item>
      <title>全局异常处理</title>
      <link>http://www.sszblog.xyz/project/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>通过RestControllerAdvice和ExceptionHandler实现全局异常捕获 起因： 我么希望通过全局统一的异常处理将自定义错误码以json的形式发送给前端。
步骤: 1.定义一个统一结果返回类BaseRspVo import com.shizhongcai.business.common.domain.enums.ErrorCodesEnum; import com.shizhongcai.business.common.exception.BaseException; import lombok.Data; @Data public class BaseRspVo&amp;lt;T&amp;gt; { private boolean success; private String msg; private Integer errorCode; private T data; public BaseRspVo() { } public BaseRspVo (T data){ this.success = true; this.msg= ErrorCodesEnum.SUCCESS.getMsg(); this.errorCode = ErrorCodesEnum.SUCCESS.getCode(); this.data = data; } public BaseRspVo (boolean success, String msg, int errorCode) { this.success = success; this.msg = msg; this.errorCode = errorCode; } public BaseRspVo (boolean success, String msg, int errorCode, T data) { this(success,msg,errorCode); this.</description>
    </item>
    
    <item>
      <title>项目开发</title>
      <link>http://www.sszblog.xyz/project/filter%E5%92%8Cinterceptor/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/filter%E5%92%8Cinterceptor/</guid>
      <description></description>
    </item>
    
    <item>
      <title>项目开发</title>
      <link>http://www.sszblog.xyz/project/jsr-303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/jsr-303%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</guid>
      <description>JSR-303参数校验 步骤 1.创建校验参数类
import lombok.Data; import org.hibernate.validator.constraints.Range; import org.springframework.format.annotation.DateTimeFormat; import javax.validation.constraints.*; import java.util.Date; /** * 参数验证请求参数 * @Author shizhongcai * @Date 2019/11/20 15:35 */ @Data public class ValidatorReqVo{ @NotNull(message = &amp;quot;id不能为空&amp;quot;) private Integer id; @NotNull @Future(message = &amp;quot;格式为yyyy-MM-dd,且为将来时间&amp;quot;) @DateTimeFormat(pattern = &amp;quot;yyyy-MM-dd&amp;quot;) private Date future; @NotNull @DecimalMin(value = &amp;quot;0.1&amp;quot;) @DecimalMax(value = &amp;quot;1000&amp;quot;) private Double doubleValue; @NotNull @Min(value = 1) @Max(value = 10) private Integer intValue; @NotNull @Range(min = 1,max = 10,message = &amp;quot;最小为1，最大为10&amp;quot;) private Integer range; @NotBlank @Email private String email; @NotBlank @Size(min = 10,max = 20,message = &amp;quot;字符串长度在10-20之间&amp;quot;) private String strSize; }  2.</description>
    </item>
    
    <item>
      <title>项目开发</title>
      <link>http://www.sszblog.xyz/project/%E5%85%B6%E4%BB%96/</link>
      <pubDate>Wed, 20 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E5%85%B6%E4%BB%96/</guid>
      <description>其他一些日常工作中遇到的问题：
1.如果需要在sit环境引入多个配置文件,比如application.yml何application-common.yml,只需要在application.yml中加入spring.profiles.include = common即可。 2.@Scope默认是单例模式，即scope=&amp;ldquo;singleton&amp;rdquo;。 另外scope还有prototype、request、session、global session作用域。scope=&amp;ldquo;prototype&amp;rdquo;多例 3.@Aspect执行顺序问题 Aspect先执行是随机的，如果需要定义顺序，可以使用@Order注解修饰Aspect类。值越小，优先级越高。</description>
    </item>
    
    <item>
      <title>基于自定义注解的参数解析器</title>
      <link>http://www.sszblog.xyz/project/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E5%9F%BA%E4%BA%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%99%A8/</guid>
      <description>基于自定义注解的参数解析器 背景 在工作中，常会对接一些第三方应用，通常第三方会采用Rsa+Aes加密来通信，但是每个第三方的加密方式可能不一致。此时得好好规划一下实现方案了。因此我们采用注解+Spring自带了参数解析类，实现自己的参数解析器。
原理 通过HandlerMethodArgumentResolver实现自定义参数解析
实现 步骤1：创建注解，例如创建一个解析Aes加密的注解AesJson import java.lang.annotation.*; @Target({ElementType.PARAMETER}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface AesJson { }  步骤2：创建加密参数实体类对象 传入的JSON数据格式为{&amp;ldquo;data&amp;rdquo;:&amp;ldquo;xxxxxxxxxx&amp;rdquo;}
import lombok.Data; @Data public class AesBaseParams { private String data; }  步骤3：新建AesArgumentResolver类实现HandlerMethodArgumentResolver import com.alibaba.fastjson.JSON; import org.apache.commons.lang.StringUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.core.MethodParameter; import org.springframework.web.bind.support.WebDataBinderFactory; import org.springframework.web.context.request.NativeWebRequest; import org.springframework.web.method.support.HandlerMethodArgumentResolver; import org.springframework.web.method.support.ModelAndViewContainer; import javax.servlet.http.HttpServletRequest; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.URLDecoder; import java.util.HashMap; import java.util.Map; import java.util.Objects; /** * aes加密算法加密的入参，通过@AesJson注解自动解析 */ public class AesArgumentResolver implements HandlerMethodArgumentResolver { private static final Logger logger = LoggerFactory.</description>
    </item>
    
    <item>
      <title>日志优化MDC</title>
      <link>http://www.sszblog.xyz/project/%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96mdc/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E6%97%A5%E5%BF%97%E4%BC%98%E5%8C%96mdc/</guid>
      <description>MDC(Mapped Diagnostic Context) 实现 步骤1：创建MDCFilter实现Filter filter（过滤器）作用于在intreceptor(拦截器)之前，不像intreceptor一样依赖于springmvc框架，只需要依赖于serverlet。 在过滤之前在reqId钟放入uuid并在结束之后remove
import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.slf4j.MDC; import org.springframework.stereotype.Component; import javax.servlet.*; import javax.servlet.http.HttpServletRequest; import java.io.IOException; import java.util.UUID; /** * @Author shizhongcai * @Date 2019/11/15 11:15 */ @Component public class MDCFilter implements Filter { private static final Logger LOG = LoggerFactory.getLogger(MDCFilter.class); public static final String MDC_ID = &amp;quot;reqId&amp;quot;; @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { boolean mdcFlag = false; try { MDC.</description>
    </item>
    
    <item>
      <title>统一返回对象</title>
      <link>http://www.sszblog.xyz/project/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E7%BB%9F%E4%B8%80%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1/</guid>
      <description>1.创建实体类BaseRspVo
@Data public class BaseRspVo&amp;lt;T&amp;gt; { private boolean success; private String msg; private Integer errorCode; private T data; public BaseRspVo() { } public BaseRspVo (T data){ this.success = true; this.msg= ErrorCodesEnum.SUCCESS.getMsg(); this.errorCode = ErrorCodesEnum.SUCCESS.getCode(); this.data = data; } public BaseRspVo(ErrorCodesEnum errorCode) { if(errorCode == ErrorCodesEnum.SUCCESS) { this.success = true; } else { this.success = false; } this.msg = errorCode.getMsg(); this.errorCode = errorCode.getCode(); } } 错误Code枚举类 public enum ErrorCodesEnum { SUCCESS(10000,&amp;quot;成功&amp;quot;), SYS_ERROR(1000,&amp;quot;系统异常，请稍后再试&amp;quot;), DUPLICATE_KEY(10001,&amp;quot;数据库中已存在该记录&amp;quot;), NO_HANDLER_FOUND(10002,&amp;quot;路径不存在，请检查路径是否正确&amp;quot;), DEFAULT_FAIL(10003,&amp;quot;未知异常，请稍后再试&amp;quot;), DECRYPT_ERROR(10004,&amp;quot;解密出错&amp;quot;), ; /** * 错误码 */ private int code; /** * 错误描述 */ private String msg; ErrorCodesEnum(int code, String msg) { this.</description>
    </item>
    
    <item>
      <title>项目开发</title>
      <link>http://www.sszblog.xyz/project/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E6%8E%A5%E5%8F%A3%E9%99%90%E6%B5%81-%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81/</guid>
      <description>guava之令牌桶算法实现接口限流 实现步骤 1.创建注解RateLimit import java.lang.annotation.*; /** * 自定义注解：限流令牌桶注解，用以创建令牌桶以及设定令牌桶大小 */ @Inherited @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface RateLimit { double limitNum() default 20; //默认每秒放入桶中20 }  2.创建令牌桶切面RateLimitAspect import com.google.common.util.concurrent.RateLimiter; import com.shizhongcai.business.common.annotation.RateLimit; import com.shizhongcai.business.common.domain.enums.ErrorCodesEnum; import com.shizhongcai.business.common.exception.BaseException; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; import java.lang.reflect.Method; import java.util.concurrent.ConcurrentHashMap; /** * 令牌桶切面，桶中无令牌进行服务降级 * */ @Component @Scope @Aspect public class RateLimitAspect { //用来存放不同接口的RateLimiter令牌桶(key为接口名称，value为RateLimiter) //ConcurrentHashMap线程安全 private ConcurrentHashMap&amp;lt;String, RateLimiter&amp;gt; map = new ConcurrentHashMap&amp;lt;&amp;gt;(); //令牌桶 private RateLimiter rateLimiter; @Pointcut(&amp;quot;@annotation(com.</description>
    </item>
    
    <item>
      <title>项目开发</title>
      <link>http://www.sszblog.xyz/project/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</link>
      <pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/project/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</guid>
      <description>Spring中Filter和Interceptor的区别 全局异常处理 统一返回结果对象 日志优化MDC(Mapped Diagnostic Context)的类（技术上使用了ThreadLocal实现，重点技术） 基于自定义注解的参数解析器（通过HandlerMethodArgumentResolver实现） 基于自定义注解的结果包装统一返回（通过HandlerMethodReturnValueHandler实现） 接口限流-令牌桶限流 参数校验-JSR-303  </description>
    </item>
    
    <item>
      <title>单例模式</title>
      <link>http://www.sszblog.xyz/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description> 单例模式 1. 2. 3. 4.静态内部类实现：
public class SingleTon{ private SingleTon(){} private static class SingleTonHoler{ private static SingleTon INSTANCE = new SingleTon(); } public static SingleTon getInstance(){ return SingleTonHoler.INSTANCE; } }  </description>
    </item>
    
    <item>
      <title>JAVA IO流</title>
      <link>http://www.sszblog.xyz/java/io%E6%B5%81/</link>
      <pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/io%E6%B5%81/</guid>
      <description>Java IO流 Java 中 IO 流分为几种?  按照流的流向分，可以分为输入流和输出流；  输出流：从内存读出到文件。只能进行写操作。 输入流：从文件读入到内存。只能进行读操作。 输入和输出，都是相对于系统内存而言  按照操作单元划分，可以划分为字节流和字符流；  字节流：以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。(1byte（B） = 8bit(位)) 字符流：以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。(1字符=2字节 )  按照流的角色划分为节点流和处理流。  节点流：直接与数据源相连，读入或读出。 处理流（Filter Stream）：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。（DataInputStream、BufferedInputStream、BufferedReader等）   Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。 - InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 - OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。
不同平台的换行符号： |符号|linux|windows|Java建议写法| |-|-|-|-| |换行符|\n|\r\n|System.getProperty(&amp;ldquo;line.separator&amp;rdquo;)| |路径分隔符|/|\|File.separator| |多个路径分隔符|:|;|File.pathSeparator|
字节流和字符流的区别: 字符流使用了缓存区（内存），执行了write()，文件中不会立刻有内容（除非缓冲区满了或者主动刷新缓冲区），需要等输出流对象关闭了，文件中才会有内容；字节流不使用缓冲区，执行了wirite()，文件中立刻就有内容了。 - ### 1.字符流
//步骤为:程序-&amp;gt;字符流-&amp;gt;缓存(数据先存放到缓存，再从缓存写入文件【主动刷新or流关闭】)-&amp;gt;文件 import java.util.*; import java.io.*; public class WriterTest { public static void main(String[] args) { File file = new File(&amp;quot;1.txt&amp;quot;); Scanner in = null; Writer out = null; try{ in = new Scanner(System.</description>
    </item>
    
    <item>
      <title>JAVA基础</title>
      <link>http://www.sszblog.xyz/java/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/java%E5%9F%BA%E7%A1%80/</guid>
      <description>Java基础知识 1. String 、StringBuilder 、StringBuffer String 类中使用 final 关键字修饰字符数组来保存字符串，private　final　char　value[]，所以 String 对象是不可变的。 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结：
操作少量的数据: 适用String 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer  2.== 和 equals == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。
equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：
 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。  说明： - String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。 - 当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</description>
    </item>
    
    <item>
      <title>Automic</title>
      <link>http://www.sszblog.xyz/java/automic/</link>
      <pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/automic/</guid>
      <description>Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。 所以，所谓原子类说简单点就是具有原子/原子操作特征的类
public final int get() //获取当前的值 public final int getAndSet(int newValue)//获取当前的值，并设置新的值 public final int getAndIncrement()//获取当前的值，并自增 public final int getAndDecrement() //获取当前的值，并自减 public final int getAndAdd(int delta) //获取当前的值，并加上预期的值 boolean compareAndSet(int expect, int update) //如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） public final void lazySet(int newValue)//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。  基本数据类型原子类优势 - ①多线程环境不使用原子类保证线程安全（基本数据类型）
class Test { private volatile int count = 0; //若要线程安全执行执行count++，需要加锁 public synchronized void increment() { count++; } public int getCount() { return count; } }   ②多线程环境使用原子类保证线程安全</description>
    </item>
    
    <item>
      <title>ThreadLocal</title>
      <link>http://www.sszblog.xyz/java/threadlocal/</link>
      <pubDate>Wed, 16 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/threadlocal/</guid>
      <description>ThreadLocal ThreadLocal是什么？ ThreadLocal是一个本地线程变量副本工具类。 保存线程上下文信息，在任意需要的地方可以获取！！！
ThreadLocal的作用？ ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。
ThreadLocal实践？ 写一个验证token的切面
@Aspect @Component public class DemoAspect { @Pointcut(&amp;quot;execution(* *.*..*Controller.*(..))&amp;quot;) public void pointService(){ } @Around(&amp;quot;pointService()&amp;quot;) public Object aroundMethod(ProceedingJoinPoint joinPoint) throws Throwable { threadLocal.set(Object); //before Object obj = null; try { obj = joinPoint.proceed(); } catch (Throwable throwable) { ... } finally{ threadLocal.remove(); } //after return obj; } } 在请求方法中可以在任意地点获取存放的本地线程副本变量  ThreadLocal注意事项 如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。
ThreadLocal与Synchronized ThreadLocal和Synchronized都是为了解决多线程中相同变量的访问冲突问题，不同的点是 - Synchronized是通过线程等待，牺牲时间来解决访问冲突 - ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，并且相比于Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值。</description>
    </item>
    
    <item>
      <title>Volatile</title>
      <link>http://www.sszblog.xyz/java/volatile/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/volatile/</guid>
      <description>首先我们需要知道原子性、可见性、有序性
原子性 即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
可见性 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
有序性 即程序执行的顺序按照代码的先后顺序执行。
int a = 10; int b = 5;  在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
ps:要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
volatile 保证 可见性 &amp;amp; 有序性，但不保证原子性
volatile:当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
为什么不保证原子性：volatile修饰的属性若再修改前被另一个线程读取了值，那么修改后，无法改变已经复制到工作内存中的值。
volatile static int a=0; a++; // 包含了2步操作：1、读取a。2、执行a+1 &amp;amp; 将a+1结果赋值给a // 设：线程A、B同时执行以下语句，线程A执行完第1步后被挂起、线程B执行了a++，那么主存中a的值为1 // 但线程A的工作内存中还是0，由于线程A之前已读取了a的值 = 0，执行a++后再次将a的值刷新到主存 = 1 // 即 a++执行了2次，但2次都是从0变为1，故a的值最终为1  为什么保证可见性： - volatile修饰的属性能够保证每次读取都是最新的值 - 但在多线程下不会 也 无法更新已经读取了的值
为什么保证有序性重排序时，以volatile修饰的属性的读/写操作代码为分界线，读/写操作前的代码不允许排到后面，后面不允许排到前面，由此保证有序性。
使用条件： 您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： - 对变量的写操作不依赖于当前值。 - 该变量没有包含在具有其他变量的不变式中。
使用场景：
 模式 #1：状态标志</description>
    </item>
    
    <item>
      <title>CountDownLatch和CyclicBarrier以及join()</title>
      <link>http://www.sszblog.xyz/java/countdownlatch%E5%92%8Ccyclicbarrier/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/countdownlatch%E5%92%8Ccyclicbarrier/</guid>
      <description>CountDownLatch、CyclicBarrier、join() 一、CountDownLatch(倒计时器)：
 功能：同步辅助类，也可以理解为倒计时锁，用于同步线程状态，允许一个或多个线程，等待其他一组线程完成操作，再继续往下执行。（会阻塞主线程） 特点：不可复用！ 重要方法：  countDown()方法：计数器-1，每次线程执行完后调用； await（）方法：等待方法，在需要阻塞的地方调用，当所有线程都执行完后，自动往下执行  用法：构造的时候指定一个计数器的值，每个线程执行完后就减1，直到为0再往下走。  二、CyclicBarrier（循环栅栏）：
 功能：同步辅助类，功能和CountDownLatch类似，用于同步线程状态，允许一组线程相互之间等待，达到一个共同点，再继续执行。(不会阻塞主线程) 特点：可复用！当组内所有线程都到达某个执行点后，count参数会被重置，于是就可重用了。 重要方法：  await（）方法：当某个线程到达某个点（比如执行完某个任务）后调用该方法，就会等待其他线程，直到所有线程都到达这个点，再自动往下执行。 还有个重载方法await（long timeOut,TimeUnit unit），用- 于当某个线程执行超过指定时间后还未到达某个点时，就会抛出异常，不再等待这个线程，并往下执行。  用法：构造的时候指定一个线程数量的值和到达某个点后执行的动作。  三、join()方法
 join方法也是管理线程状态同步的一个方法，和CountDownLatch和CyclicBarrier均由自身调用不同的是，join的调用者为当前线程，后面的线程必须等调用join的线程执行完后才能执行。  refer to:https://www.cnblogs.com/be-thinking/p/9292290.html refer to:https://blog.csdn.net/qq_39241239/article/details/87030142</description>
    </item>
    
    <item>
      <title>Java8-简化代码</title>
      <link>http://www.sszblog.xyz/java/java8-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/java8-%E7%AE%80%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Synchronized关键字</title>
      <link>http://www.sszblog.xyz/java/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>Synchronized关键字 1.作用 保证同一时刻最多只有1个线程执行 被Synchronized修饰的方法 / 代码
其他线程 必须等待当前线程执行完该方法 / 代码块后才能执行该方法 / 代码块
2.修饰 2.1修饰方法 //对象锁 //写法1 public synchronized void method() { // todo } //写法2，写法2其实是同步代码块的写法，但在这里也是相当于修饰了方法 public void method() { synchronized(this) { // todo } }  2.2修饰静态方法 //类锁 public synchronized static void method() { // todo }  2.3修饰类 //类锁 class ClassName { public void method() { synchronized(ClassName.class) { // todo } } }  2.4修饰代码块 //对象锁 //写法一 synchronized(this) { //todo } //写法二 Object obj =new Object(); synchronized(obj) { //todo }  3.</description>
    </item>
    
    <item>
      <title>Future、FutureTask、CompletableFuture</title>
      <link>http://www.sszblog.xyz/java/futurefuturetaskcompletablefuture/</link>
      <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/futurefuturetaskcompletablefuture/</guid>
      <description>Future
public interface Future&amp;lt;V&amp;gt; { /** * 取消任务的执行 * 如果任务已经完成，或者已经被取消，或者因为其他原因不能被取消，则返回失败 * 如果任务在调用时还未启动，那么返回成功 * 如果任务已经在执行过程中，则根据参数确定此执行任务的线程能否被中断，来试图停止任务的执行 * @param mayInterruptIfRunning * @return */ boolean cancel(boolean mayInterruptIfRunning); /** * 判断任务是否已经取消，任务正常完成前将其取消，则返回true * @return */ boolean isCancelled(); /** * 判断任务是否已经完成，需要注意的是如果任务正常、异常或取消，都返回true * @return */ boolean isDone(); /** * 等待任务执行结束，并返回结果 * @return * @throws InterruptedException 线程被中断异常 * @throws ExecutionException 任务执行异常 */ V get() throws InterruptedException, ExecutionException; /** * 等待任务执行结束，并返回结果，同上面get方法的区别是设置了超时时间， * @param timeout * @param unit * @return * @throws InterruptedException * @throws ExecutionException * @throws TimeoutException */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; }  FutureTask介绍</description>
    </item>
    
    <item>
      <title>短语</title>
      <link>http://www.sszblog.xyz/other/english/phrase/</link>
      <pubDate>Wed, 09 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/other/english/phrase/</guid>
      <description>Managerial tasks could be delegated to others 管理任务可以委托给其他人</description>
    </item>
    
    <item>
      <title>linux命令</title>
      <link>http://www.sszblog.xyz/linux/linux%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/linux/linux%E6%93%8D%E4%BD%9C/</guid>
      <description>一行shell命令杀死指定进程名称的进程方法
ps -efww|grep -w &#39;程序名称&#39;|grep -v grep|cut -c 9-15|xargs kill -9  ps:杀死程序名称为ssz-h5的程序
[root@sagdb ssz-h5]# ps -ef|grep java root 28414 1 2 Sep27 ? 05:39:12 java -jar ssz-llyy.jar root 29837 1 99 14:37 pts/0 00:00:03 java -jar ssz-h5.jar root 29856 29557 0 14:37 pts/0 00:00:00 grep java [root@sagdb ssz-h5]# ps -efww|grep -w &#39;ssz-h5&#39;|grep -v grep|cut -c 9-15|xargs kill -9  </description>
    </item>
    
    <item>
      <title>Thread、Runnable、Callable、线程池</title>
      <link>http://www.sszblog.xyz/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>1.创建线程的三种方式  (1)继承thread,重写run方法 (2)实现Runnable接口，实现run方法 (3)实现Callable接口，实现call方法 (4)线程池  2.Runnable和Callable的区别：  (1)Callable实现的方法是call(),Runnable实现的方法是run(). (2)Callable的任务执行后可返回值，可以拿到一个Future对象，而Runnable的任务没有返回值 (3)call方法需要抛出异常InterruptedException和ExecutionExecption，run方法只能在内部消化InterruptedException  3.Thread的缺点：  Java是单继承多实现，不利于扩展.  4. 线程池 4.1 为什么要使用线程池  降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。  4.2 execute()和submit()的区别  (1)可接受任务类型：
 submit:
submit(Callable&amp;lt;T&amp;gt; task):Future&amp;lt;T&amp;gt; -ExecutorService submit(Runnable task):Future&amp;lt;?&amp;gt; -ExecutorService submit(Runnable task,T result):Future&amp;lt;T&amp;gt; -ExecutorService  execute:
execute(Runnable command):void -Executor  从源码种可以看出
 execute只能接受Runnable类型的任务 submit不管是Runnable还是Callable类型的任务都可以接受   (2)返回值
 由Callable和Runnable的区别可以看出：  execute没有返回值 submit有返回值，所以需要返回值的时候必须使用submit   (3)异常处理
 submit在执行过程中与execute不一样，不会抛出异常而是把异常保存在成员变量中，在FutureTask.get阻塞获取的时候再把异常抛出来。
 execute中抛出异常 execute中的是Runnable接口的实现，所以只能使用try、catch来捕获CheckedException，通过实现UncaughtExceptionHande接口处理UncheckedException 即和普通线程的处理方式完全一致</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>http://www.sszblog.xyz/java/%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E5%BC%82%E5%B8%B8/</guid>
      <description>异常和错误的区别：异常能被程序本身处理，错误是无法处理。</description>
    </item>
    
    <item>
      <title>责任链模式使用</title>
      <link>http://www.sszblog.xyz/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 26 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8/</guid>
      <description>责任链模式的重点在“链上”，由一条链去处理相似的请求，在链中决定谁来处理这个请求，并返回相应的结果。
角色：
抽象处理者（Handler）角色：该角色对请求进行抽象，并定义一个方法来设定和返回对下一个处理者的引用。
具体处理者（Concrete Handler）：该角色接到请求后，可以选择将请求处理掉，或者将请求传给下一个处理者。由于具体处理者持有对下一个处理者的引用，因此，如果需要，处理者可以访问下一个处理者。
优点 责任链模式将请求和处理分开，请求者不知道是谁处理的，处理者可以不用知道请求的全貌。 提高系统的灵活性。 缺点 降低程序的性能。每个请求都是从链头遍历到链尾，当链比较长的时候，性能会大幅下降。 不易于调试。由于该模式采用了类似递归的方式，调试的时候逻辑比较复杂。</description>
    </item>
    
    <item>
      <title>Java8计算时间差</title>
      <link>http://www.sszblog.xyz/java/java8%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE/</link>
      <pubDate>Mon, 23 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/java8%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E5%B7%AE/</guid>
      <description>&lt;p&gt;&lt;strong&gt;计算某个并行任务的总耗时。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的书单</title>
      <link>http://www.sszblog.xyz/other/%E4%B9%A6%E5%8D%95/%E4%B9%A6%E5%8D%95/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/other/%E4%B9%A6%E5%8D%95/%E4%B9%A6%E5%8D%95/</guid>
      <description> [ ]《睡眠革命》
 [x]《软技能》
 [ ]《指数基金投资指南》
 [ ]《解读基金》
 [ ]《傻瓜式投资》
 [ ]《习惯的力量》
 [ ]《人性的弱点》
 [ ]《金字塔原理》 [ ]《董莉华之书》  </description>
    </item>
    
    <item>
      <title>软技能分享</title>
      <link>http://www.sszblog.xyz/other/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/%E8%BD%AF%E6%8A%80%E8%83%BD%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/</link>
      <pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/other/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/%E8%BD%AF%E6%8A%80%E8%83%BD%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/</guid>
      <description>#《软技能》 前言 对于优秀的软件开发者来说，埋头写代码绝并不应该是工作的全部。这本书给出了很多非常好的建议，不仅仅“码农”们可以从中获益，还可以推而广之到很多其他的行业。
职业 主要讲的是如何进行自己的职业规划
你所能犯的最大错误就是相信自己是在为别人工作。这样一来你对工作的安全感已然尽失。职业发展的驱动力一定是个体本身。记住：工作是属于公司的，而职业生涯确实属于你自己的。 - 厄尔.南丁格尔
那么我们该如何解决这样的问题呢？
思考未来，你的目标是什么（√） 工作属于公司的，而职业属于自己的。没有目标的就更不可能去实现自己的目标，浑浑噩噩混过一生，这个是大多数人的自然状态，我们通常保护会充分思考自己该关注什么，这样我们的行动也就漫无目的，无的放矢。（想象一下，海中的船只）。 为什么需要目标？ 如何设定目标。 首先，必须定义一个大目标，不需要那么具体，但是一定要清晰，能够让你自己知道你自己是再向它前进还是离它越来越远。
如果你可以驱动小目标逐渐前行并靠近你的大目标， 那么最终你一定会到达目的地。 设定大小不同的目标， 确保你向着自己的大目标前进， 这一点非常重要。 例如， 你设定了 一个年度目标， 阅读很多技术书籍， 或是学习新的编程语言。 这个年度目标可能是引领你 走向“成为一名高级开发人员”这个大目标的小目标。 同样， 每年的目标可能被分解成更小 的目标， 比如每月阅读一本书， 或者每天读多少页。
　较小的目标可以让你航行在自己的轨道上， 激励你保持航向朝着更大的目标前进。 如 果你准备达成一个大目标， 却没有分解为小目标， 那么当你偏离航向时也不会有时间去校 正。 达成较小的目标也能经常奖励自己， 帮助并激励自己。 每一天、 每一个星期的小胜利 会让我们觉得自己正在取得进展、 达成目标， 这让我们感觉良好， 帮助我们继续前进。 较 小的目标似乎也不像大目标那样令人望而生畏
追踪你的目标。
采取行动
 坐下来，为职业生涯设置至少一个大目标。 将大目标分解成若干个小目标，例如  月度目标 周目标 每日目标  把大目标写在每天的必经之地，达到吾日三省吾身的效果  学会与人打交道（√） ‘别管我，我只想一个人安静地写代码！’
是不是每天想安安静静地写代码时，微信窗口或者Email总会不合时宜地弹出各种提示，一会要开会啦一会要讨论需求了，再一会测试又来和你理论Bug了。世界这么喧嚣，还让不让人安静地写代码了？“别管我，我只想一个人安静地写代码”，这句话道出了多少程序员的心声啊，我们都想“静静”！不过今天我要告诉你，这种想法是多么的错误，并且严重影响了你职业生涯的发展。
如果你觉得自己的工作就是写写代码，那你最好三思。在开发的领域，我们大多数是与人而不是与计算机打交道。我们所写的代码首先是供人使用的，其次才是让计算机可以理解的，如果你只想和机器打交道，那写二进制的代码机器才能理解你。仔细想想自己一天的工作中有多少时间用在了与人互动上，收发邮件、会议、讨论（扯皮）等等，作为一个开发人员，你的工作就是与人打交道（其实几乎所有的职业都是这样）。
所以，虽然你是一个码代码的码农，看似你工作的重心是在码代码上，但其实你自己统计一下也会发现：你真正写代码的时间占你工作时间的比例并不高甚至有些人非常低。即使没有人打扰你，你仍然需要花很多的时间去设计（思考）怎么写你的代码，或者花很长的时间去看懂别人的代码然后找到Bug产生的原理，这个过程中看似你面对的是代码是机器，但其实你面对的是人（写代码的人和读你代码的人）。这还没有谈论怎么把业务的需求变成代码，你仍然需要了解一定的业务知识，当然最好的方式是先和业务、需求设计人员进行沟通，而不是闷头写代码。
那么问题来了，如何与人打交道呢？ 许多优秀的书籍都阐述了“如何与人打交道“这个主题，再这本书中作者强烈推荐《人性的弱点》这本书，此外作者还在这一篇中引用了这本书中的一些观点。 1. 每个人都希望感到自己很重要 我们常常容易犯的一项错误就是，轻率地否决同事的想法，以便于可以提出自己的想法。然而随着你做出这样的错误判断，你往往会发现他们对你的想法充耳不闻，仅仅因为你让他们感觉自己是无足轻重的。如果你希望人们接受你的想法，并认可其中的价值，首先你最好先主动给他人相同的礼遇。如果你不能保全他人的自尊，那你永远也不可能赢得他的心。 2.</description>
    </item>
    
    <item>
      <title>git创建新仓库</title>
      <link>http://www.sszblog.xyz/git/git%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/git/git%E6%93%8D%E4%BD%9C/</guid>
      <description>&lt;p&gt;通过命令行方式对本地文件创建git，再远程创建git并提交。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java8相关</title>
      <link>http://www.sszblog.xyz/java/java8/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/java8/</guid>
      <description>&lt;p&gt;&lt;strong&gt;阅读Java8实战后的一些笔记&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>markdown模板</title>
      <link>http://www.sszblog.xyz/markdown/markdown/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/markdown/markdown/</guid>
      <description>&lt;p&gt;&lt;strong&gt;markdown模板&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.shields.io/github/release/wildfirechat/server&#34; alt=&#34;版本图标&#34; /&gt;
类似于这样添加版本
&lt;img src=&#34;http://progressed.io/bar/10&#34; alt=&#34;Progress&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/f/wolves&#34;&gt; &lt;img src=&#34;https://travis-ci.org/f/wolves.svg?branch=master&#34; alt=&#34;Build Status&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;http://badge.fury.io/js/wolves&#34;&gt; &lt;img src=&#34;https://badge.fury.io/js/wolves.svg&#34; alt=&#34;NPM version&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://david-dm.org/f/wolves#info=dependencies&amp;amp;view=table&#34;&gt; &lt;img src=&#34;https://david-dm.org/f/wolves/status.svg&#34; alt=&#34;Dependencies&#34; /&gt;&lt;/a&gt;
&lt;a href=&#34;https://david-dm.org/f/wolves#info=devDependencies&amp;amp;view=table&#34;&gt; &lt;img src=&#34;https://david-dm.org/f/wolves/dev-status.svg&#34; alt=&#34;Dev Dependencies&#34; /&gt;&lt;/a&gt;
类似于这样添加进度&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>xml与json互转</title>
      <link>http://www.sszblog.xyz/java/xml%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/xml%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;p&gt;&lt;strong&gt;开发场景中，需要对返回的xml数据转为json再进行处理&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的单词本</title>
      <link>http://www.sszblog.xyz/other/english/word/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/other/english/word/</guid>
      <description>&lt;p&gt;&lt;strong&gt;日常开发中遇到的一些术语生词&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>按指定长度切割list</title>
      <link>http://www.sszblog.xyz/java/%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E5%88%87%E5%89%B2list/</link>
      <pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E5%88%87%E5%89%B2list/</guid>
      <description>&lt;p&gt;&lt;strong&gt;某一次需求开发中，遇到这样的场景，需要对名单进行分组然后再对这批名单处理。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.sszblog.xyz/java/%E5%85%B6%E4%BB%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.sszblog.xyz/java/%E5%85%B6%E4%BB%96/</guid>
      <description>Maps.newHashMapWithExpectedSize(1)；创建固定长度的map;</description>
    </item>
    
  </channel>
</rss>